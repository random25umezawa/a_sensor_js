<html>
<head>
	<meta charset="UTF-8">
	<title>加速度ツール</title>
	<style>
	*{
		font-size: 50px;
	}
	td{
		width: 25%;
		text-align: right;
	}
	.func{
		border:1px solid #bbb;
		padding: 5px;
		margin: 5px;
	}
	</style>
	<script src="minMatrix.js"></script>
	<script type="text/javascript" src="LZWEncoder.js"></script>
	<script type="text/javascript" src="NeuQuant.js"></script>
	<script type="text/javascript" src="GIFEncoder.js"></script>
</head>
<body>
	<button id="timerbutton" style="width:400px; height:80px;">計測開始</button><br>
	x:<span id="span_x"> 0.000</span><br>
	y:<span id="span_y"> 0.000</span><br>
	z:<span id="span_z"> 0.000</span><br>
	<canvas id="canvas_3dcg" width="256" height="256"></canvas>
	<div class="func">
		<button onclick="download();" style="width:300px; height:80px;">csv取得</button><br>
		filename:<input id="filename" style="width:12em;">
	</div>
	<div id="div_canvas" style="overflow-x:scroll; width:80%;">
		<canvas id="canvas" width="500" height="300"></canvas>
	</div>
	<div id="div_progress_message">DOM形成中...</div>
	<progress id="dom_progress"></progress>
	<table border="1">
		<tr style="text-align:center;">
			<td>time</td>
			<td>x</td>
			<td>y</td>
			<td>z</td>
		</tr>
		<tbody id="table_result">
		</tbody>
	</table>
</body>
<script>
//各種dom
var span_x,span_y,span_z;
var timerbutton;
var table_result;
var div_progress_message;
var dom_progress;

//各種設定値
var min_deltatime = 0;	//これより短いdtでのサンプリング値を無視する(ms)
var render_realtime_flag = true;	//計測中にグラフ描画や値表示をするか
var render_aftersensing = true;	//計測終了後に結果をテーブルに表示するか
var fix_num = 3;	//小数以下何桁まで表示するか

//一時処理用
var sensor_flag = false;	//今計測中か
var time = (+new Date());	//計測中のタイム
var startTime = (+new Date());	//計測開始時間
var result = [];	//計測値格納

//canvas系
var canvas;
var g;
var div_canvas;
var div_canvas_width;	//canvas自体を囲っているdivの長さ(画面幅基準で割合指定されていて,自動スクロール処理に使う)
var canvas_width = 0;
var canvas_height = 300;
var canvas_half_height = canvas_height/2;
var width_per_millisecond = 0.25;	//１秒に(1000*この値)pxグラフが進む
var canvas_height_rate = 0.05;	//(1/この値)までの加速度値をはみ出さずに表示できる


window.onload = function() {
	span_x = document.getElementById("span_x");
	span_y = document.getElementById("span_y");
	span_z = document.getElementById("span_z");
	timerbutton = document.getElementById("timerbutton");
	table_result = document.getElementById("table_result");
	div_canvas = document.getElementById("div_canvas");
	div_canvas_width = div_canvas.clientWidth;
	canvas = document.getElementById("canvas");
	canvas.width=canvas_width;
	canvas.height=canvas_height;
	div_progress_message = document.getElementById("div_progress_message");
	dom_progress = document.getElementById("dom_progress");
	div_progress_message.style.visibility = "hidden";
	dom_progress.style.visibility = "hidden";
	g = canvas.getContext("2d");

	init3d();

	timerbutton.onclick = function() {
		if(sensor_flag) {
			timerbutton.innerHTML = "計測開始";
			timerEnd();
		}else {
			timerbutton.innerHTML = "計測終了";
			timerStart();
		}
	}

	window.addEventListener("devicemotion", function(e){
		if(sensor_flag) {
			var newTime = (+new Date());
			if(newTime-time>min_deltatime) {
				var x = fixNumber(e.acceleration.x);
				var y = fixNumber(e.acceleration.y);
				var z = fixNumber(e.acceleration.z);
				var allTime = newTime-startTime;
				if(render_realtime_flag) {
					span_x.innerHTML = x;
					span_y.innerHTML = y;
					span_z.innerHTML = z;
					canvasDraw();
				}
				time = newTime;
				result.push([fixNumber(allTime/1000),x,y,z]);
			}
		}
	});
};

function canvasDraw() {
	//初期化
	g.fillStyle = "#fff";
	g.fillRect(0,0,canvas_width,canvas_height);

	//大きさ調整
	var _maxlength = result[result.length-1][0]*1000*width_per_millisecond;
	if(canvas_width<_maxlength) {
		canvas.width = _maxlength;
		canvas_width = _maxlength;
	}
	graphDraw(1,"#f00",0);
	graphDraw(2,"#0f0",0);
	graphDraw(3,"#00f",0);

	//自動スクロール
	var scroll = canvas_width-div_canvas_width;
	if(scroll>0) div_canvas.scrollLeft = scroll;
}

function graphDraw(_index, _color, _start=0) {
	g.strokeStyle = _color;
	var _startTime = result[_start][0];
	g.beginPath();
	g.moveTo(0,canvas_half_height);
	for(var i = _start+1; i < result.length; i++) {
		g.lineTo((result[i][0]-_startTime)*1000*width_per_millisecond,canvas_half_height+canvas_half_height*result[i][_index]);
	}
	g.stroke();
}

function timerStart() {
	result = [[0,0,0,0]];
	table_result.innerHTML = "";
	canvas_width = 0;
	canvas.width = 0;
	time = (+new Date());
	startTime = (+new Date());
	sensor_flag = true;
}

function timerEnd() {
	sensor_flag = false;
	div_progress_message.style.visibility = "visible";
	dom_progress.style.visibility = "visible";
	dom_progress.max = result.length;
	dom_progress.value = 0;
	if(render_aftersensing) make_table(0);
}

function make_table(start) {
	if(result.length>start) {
		table_result.innerHTML += make_dom(result[start]);
		dom_progress.value = start;
		setTimeout("make_table("+(start+1)+")",1);
	}else {
		div_progress_message.style.visibility = "hidden";
		dom_progress.style.visibility = "hidden";
	}
}

function download() {
	var filename = document.getElementById("filename").value;
	if(filename=="") filename = "sensor_data";
	var outputText = "time,x,y,z\n";
	for(var i = 0; i < result.length; i++) {
		outputText += `${result[i][0]},${result[i][1]},${result[i][2]},${result[i][3]}\n`;
	}
	var blob = new Blob([outputText],{"type":"text/plain"});
	var a = document.createElement("a");
	a.href = URL.createObjectURL(blob);
	a.targer = '_blank';
	a.download = filename+'.csv';
	a.click();
}

function make_dom(_arr) {
	return `
		<tr>
			<td>${_arr[0]}</td>
			<td>${_arr[1]}</td>
			<td>${_arr[2]}</td>
			<td>${_arr[3]}</td>
		</tr>
	`
}

function fixNumber(_num) {
	var num = new Number(_num).toFixed(fix_num);
	//if(num>=0) num = " "+num;
	return num;
}

</script>

<script src="./cg3d.js"></script>

</html>
